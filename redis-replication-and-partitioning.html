<!DOCTYPE html><html><head><meta charSet="utf-8"/><link rel="preconnect" href="https://www.google-analytics.com"/><link rel="preload" href="https://fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic&amp;display=optional" as="style"/><title>Redis: Replication and Partitioning</title><meta name="description" content="Rafael Eyng&#x27;s tech blog"/><meta name="language" content="en"/><meta name="content-language" content="en"/><meta name="author" content="Rafael Eyng"/><meta name="keywords" content="software, development, javascript, github, node, docker, blog"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="canonical" href="https://rafaeleyng.github.io/redis-replication-and-partitioning"/><link rel="shortcut icon" href="/favicon.png" type="image/x-icon"/><link href="https://fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic&amp;display=optional" rel="stylesheet" type="text/css"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-154633858-1"></script><script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-154633858-1');
</script><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/9266c75324afaf787c37a5040eafbe2f741a2e2e_CSS.7b3f6175.chunk.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9266c75324afaf787c37a5040eafbe2f741a2e2e_CSS.7b3f6175.chunk.css"/><link rel="preload" href="/_next/static/wYcTpx5CeNbW7H8pWV5MK/pages/post.js" as="script"/><link rel="preload" href="/_next/static/wYcTpx5CeNbW7H8pWV5MK/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-9369c5c69dbf6d4912cb.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.03885e3762b811c06d48.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.2d46a4062a63030a7155.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-b1931ae9be17f1491bfa.js" as="script"/><link rel="preload" href="/_next/static/chunks/a1bc03cf.0a53ccc93557b67d94bb.js" as="script"/><link rel="preload" href="/_next/static/chunks/9266c75324afaf787c37a5040eafbe2f741a2e2e.d3bd6b30cfbcf1be71b2.js" as="script"/><link rel="preload" href="/_next/static/chunks/9266c75324afaf787c37a5040eafbe2f741a2e2e_CSS.37da1e6c94fa5227f4d3.js" as="script"/></head><body><div id="__next"><div class="container"><header class="site-header single-column"><a class="blog-title" href="/">Rafael Eyng&#x27;s Blog</a><nav class="blog-menu"><a target="_blank" rel="noopener" href="https://rafaeleyng.github.io/me">About</a><a target="_blank" rel="noopener" href="https://github.com/rafaeleyng/rafaeleyng.github.io">Github</a></nav></header></div><header class="page-header"><div class="container single-column"><h1>Redis: Replication and Partitioning</h1><p class="post-meta"><time itemProp="datePublished" dateTime="2019-11-24">Nov 24, 2019</time></p></div></header><main class="container single-column"><section class="post"><span class="hidden" itemProp="publisher">Rafael Eyng</span><span class="hidden" itemProp="keywords">redis, replication, partitioning, distributed system</span><article class="post-content" itemProp="articleBody"><p>Replication and partitioning are techniques that build the foundation of using Redis as a distributed system. In this post they will be examined as very basic building blocks. For more complex needs, there are more complex abstractions, like Redis Sentinel and Redis Cluster, that build upon these building blocks.</p><h2>Replication</h2><p>Replication means keeping multiple copies of the same data, so in case we lose one of the copies, we still can recover the data from the other copies. Here we will analyze Redis replication at its most basic level.</p><p>Redis provides a basic <em>leader follower</em> replication, allowing us to have a master-replica setup. We can have one or multiple replicas for some master. This is done on the configuration file of the replica instances, using the configuration:</p><pre><code>replicaof &quot;my-master-hostname&quot; &quot;6379&quot;</code></pre><p>If you are using authentication on your Redis setup, you&#x27;ll need some extra configuration to specify the password.</p><p>Once the configuration is done, each replica will stay connected to the master and receive from the master a stream of commands to create its own local copy of the dataset.</p><h3>Benefits of replication</h3><p>This basic replication setup has the immediate benefit of improving data safety. If you happen to lose the data on your master, you still can recover the data from your replicas. (only what was already sent to the replicas before the failure) If a replica fails or loses connection to the master, it will automatically resynchronize its data with the master once the connection is recovered. So it can help with high-availability of read-only nodes.</p><p>The second main benefit is being able to use the replicas as read-only Redis servers, and use them to make any slow O(N) queries you might need, offloading some work from the master, whose job is receiving all the writes or receiving the faster queries.</p><h3>Limitations of replication</h3><p>Replicas are read-only by default, so write commands issued against a replica will fail. There are configurations around this, check the documentation for more information.</p><p>Replication is asynchronous. This means that the master will acknowledge a write to the client before the write was successfully propagated to a replica. This creates the possibility of data loss, if the master fails after acknowledging the write but before propagating to the replica. Again, there are configurations around this to make it more safe (at the cost of worse performance).</p><p>Also, this setup does not provide any automatic failover. It is still your job to restart the master after a failure.</p><h3>When you should use replication</h3><p>You should use this very simple setup when (all of the bellow):</p><ul><li>when you cannot afford to lose the data on your master</li><li>when you don&#x27;t need automatic failover (if you need it, use Redis Sentinel)</li></ul><p>You can also use it when you can benefit from having read-only replicas to offload some work from the master.</p><h2>Partitioning</h2><p><a href="https://redis.io/topics/partitioning">The docs</a> have a really good definition of partitioning:</p><blockquote><p>Partitioning is the process of splitting your data into multiple Redis instances, so that every instance will only contain a subset of your keys.</p></blockquote><p>When using partitioning, some partitioning criteria is needed, to decide on which Redis server a given key should be located. The three main criterias are range partitioning, hash partitioning and consistent hashing.</p><p>Redis Cluster is the state-of-the-art way of working with partitioning in Redis, but for simpler cases you might need to handle the partitioning manually.</p><p>The actual partitioning (the mapping of a key to a Redis server) can happen in different parts of the stack:</p><ul><li>client side partitioning: the client computes the server from the key.</li><li>proxy assisted partitioning: a proxy (like <a href="https://github.com/twitter/twemproxy">Twemproxy</a>) sits in between client and servers and computes the correct server from the key.</li><li>query routing: is the technique used by Redis Cluster, in which any Redis node can receive a query and will redirect the client to the correct node, given the partitioning scheme.</li></ul><h3>Benefits of replication</h3><p>Partitioning allows you to have larger datasets. If your dataset is 10Gb, but you only have nodes with 4Gb of memory, you can use 3 nodes and partition your data between the 3 nodes.</p><p>Also, partitioning allows you to split the work load between multiple nodes, scaling the computational power of your Redis setup to multiple CPUs and network adapters, instead of the single CPU and network adapter of a single-node setup.</p><h3>Limitations of partitioning</h3><p>When you have keys distributed among multiple nodes, some operations involving multiple keys become useless. Like trying to compute the intersection between two sets will only work if the two keys are in the same node, which is something that the programmer should rely on. The same goes for transactions involving multiple keys.</p><p>Other limitation is regarding the partitioning granularity. Given the partition granularity is the key, a single key containing a huge list or set cannot be partitioned between multiple nodes.</p><p>At last, changing the system capacity (adding or removing nodes) is hard, because there is no automatic rebalancing mechanism. Redis Cluster solves this.</p><h3>When you should use partitioning</h3><p>You should use this very simple partitioning when (one of the bellow):</p><ul><li>when your Redis dataset is too big to fit in the memory of a single node</li><li>when you have a volume of requests that a single Redis node cannot keep up, and you want to distribute the load to multiple instances</li></ul><h2>References</h2><ul><li><a href="https://redis.io/topics/replication">https://redis.io/topics/replication</a></li><li><a href="https://redis.io/topics/partitioning">https://redis.io/topics/partitioning</a></li></ul></article><div id="disqus_thread"></div><script type="text/javascript">
var disqus_config = function () {
  this.page.url = 'https://rafaeleyng.github.io/redis-replication-and-partitioning';
  this.page.identifier = '/redis-replication-and-partitioning';
};

(function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = 'https://rafaeleyng.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
})();
</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript></section></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"document":{"content":"\nReplication and partitioning are techniques that build the foundation of using Redis as a distributed system. In this post they will be examined as very basic building blocks. For more complex needs, there are more complex abstractions, like Redis Sentinel and Redis Cluster, that build upon these building blocks.\n\n## Replication\n\nReplication means keeping multiple copies of the same data, so in case we lose one of the copies, we still can recover the data from the other copies. Here we will analyze Redis replication at its most basic level.\n\nRedis provides a basic *leader follower* replication, allowing us to have a master-replica setup. We can have one or multiple replicas for some master. This is done on the configuration file of the replica instances, using the configuration:\n\n```\nreplicaof \"my-master-hostname\" \"6379\"\n```\n\nIf you are using authentication on your Redis setup, you'll need some extra configuration to specify the password.\n\nOnce the configuration is done, each replica will stay connected to the master and receive from the master a stream of commands to create its own local copy of the dataset.\n\n### Benefits of replication\n\nThis basic replication setup has the immediate benefit of improving data safety. If you happen to lose the data on your master, you still can recover the data from your replicas. (only what was already sent to the replicas before the failure) If a replica fails or loses connection to the master, it will automatically resynchronize its data with the master once the connection is recovered. So it can help with high-availability of read-only nodes.\n\nThe second main benefit is being able to use the replicas as read-only Redis servers, and use them to make any slow O(N) queries you might need, offloading some work from the master, whose job is receiving all the writes or receiving the faster queries.\n\n### Limitations of replication\n\nReplicas are read-only by default, so write commands issued against a replica will fail. There are configurations around this, check the documentation for more information.\n\nReplication is asynchronous. This means that the master will acknowledge a write to the client before the write was successfully propagated to a replica. This creates the possibility of data loss, if the master fails after acknowledging the write but before propagating to the replica. Again, there are configurations around this to make it more safe (at the cost of worse performance).\n\nAlso, this setup does not provide any automatic failover. It is still your job to restart the master after a failure.\n\n### When you should use replication\n\nYou should use this very simple setup when (all of the bellow):\n- when you cannot afford to lose the data on your master\n- when you don't need automatic failover (if you need it, use Redis Sentinel)\n\nYou can also use it when you can benefit from having read-only replicas to offload some work from the master.\n\n## Partitioning\n\n[The docs](https://redis.io/topics/partitioning) have a really good definition of partitioning:\n\n\u003e Partitioning is the process of splitting your data into multiple Redis instances, so that every instance will only contain a subset of your keys.\n\nWhen using partitioning, some partitioning criteria is needed, to decide on which Redis server a given key should be located. The three main criterias are range partitioning, hash partitioning and consistent hashing.\n\nRedis Cluster is the state-of-the-art way of working with partitioning in Redis, but for simpler cases you might need to handle the partitioning manually.\n\nThe actual partitioning (the mapping of a key to a Redis server) can happen in different parts of the stack:\n- client side partitioning: the client computes the server from the key.\n- proxy assisted partitioning: a proxy (like [Twemproxy](https://github.com/twitter/twemproxy)) sits in between client and servers and computes the correct server from the key.\n- query routing: is the technique used by Redis Cluster, in which any Redis node can receive a query and will redirect the client to the correct node, given the partitioning scheme.\n\n### Benefits of replication\n\nPartitioning allows you to have larger datasets. If your dataset is 10Gb, but you only have nodes with 4Gb of memory, you can use 3 nodes and partition your data between the 3 nodes.\n\nAlso, partitioning allows you to split the work load between multiple nodes, scaling the computational power of your Redis setup to multiple CPUs and network adapters, instead of the single CPU and network adapter of a single-node setup.\n\n### Limitations of partitioning\n\nWhen you have keys distributed among multiple nodes, some operations involving multiple keys become useless. Like trying to compute the intersection between two sets will only work if the two keys are in the same node, which is something that the programmer should rely on. The same goes for transactions involving multiple keys.\n\nOther limitation is regarding the partitioning granularity. Given the partition granularity is the key, a single key containing a huge list or set cannot be partitioned between multiple nodes.\n\nAt last, changing the system capacity (adding or removing nodes) is hard, because there is no automatic rebalancing mechanism. Redis Cluster solves this.\n\n### When you should use partitioning\n\nYou should use this very simple partitioning when (one of the bellow):\n- when your Redis dataset is too big to fit in the memory of a single node\n- when you have a volume of requests that a single Redis node cannot keep up, and you want to distribute the load to multiple instances\n\n## References\n\n- https://redis.io/topics/replication\n- https://redis.io/topics/partitioning\n","data":{"title":"Redis: Replication and Partitioning","date":"2019-11-25T00:00:00.000Z","keywords":"redis, replication, partitioning, distributed system","excerpt":"Replication and partitioning are techniques that build the foundation of using Redis as a distributed system, and prepare the way for more complex abstractions like Redis Sentinel and Redis Cluster\n"}},"slug":"redis-replication-and-partitioning"}}},"page":"/post","query":{"slug":"redis-replication-and-partitioning"},"buildId":"wYcTpx5CeNbW7H8pWV5MK","nextExport":true,"isFallback":false}</script><script nomodule="" src="/_next/static/runtime/polyfills-4f88fede4464c0c2d393.js"></script><script async="" data-next-page="/post" src="/_next/static/wYcTpx5CeNbW7H8pWV5MK/pages/post.js"></script><script async="" data-next-page="/_app" src="/_next/static/wYcTpx5CeNbW7H8pWV5MK/pages/_app.js"></script><script src="/_next/static/runtime/webpack-9369c5c69dbf6d4912cb.js" async=""></script><script src="/_next/static/chunks/framework.03885e3762b811c06d48.js" async=""></script><script src="/_next/static/chunks/commons.2d46a4062a63030a7155.js" async=""></script><script src="/_next/static/runtime/main-b1931ae9be17f1491bfa.js" async=""></script><script src="/_next/static/chunks/a1bc03cf.0a53ccc93557b67d94bb.js" async=""></script><script src="/_next/static/chunks/9266c75324afaf787c37a5040eafbe2f741a2e2e.d3bd6b30cfbcf1be71b2.js" async=""></script><script src="/_next/static/chunks/9266c75324afaf787c37a5040eafbe2f741a2e2e_CSS.37da1e6c94fa5227f4d3.js" async=""></script><script src="/_next/static/wYcTpx5CeNbW7H8pWV5MK/_buildManifest.js" async=""></script><script src="/_next/static/wYcTpx5CeNbW7H8pWV5MK/_ssgManifest.js" async=""></script></body></html>